\chapter{Konzept}

Für die Untersuchung des Optimierungsalgorithmus wird ein experimenteller
Ansatz statt einem analytischem gewählt, da die experimentelle Vorgehensweise
es zum einen einfacher macht sehr komplexe Algorithmen zu untersuchen, zum
anderen, eine experimentelle Untersuchung realitätsnähere Ergebnisse liefern kann
\autocite[vgl.][S.3]{ExperimentalMethods}.
Hierzu werden in dieser Arbeit zwei unabhängige Variablen betrachtet. Zum einen
die Größe und zum anderen der Aufbau des zu optimierenden Modells, diese wurden
gewählt, da sie direkt kontrolliert werden können und erwartet wird, dass sie
einen großen Einfluss auf die Laufzeit haben
\autocite[vgl.][S.506]{ExperimentalAnalysis}. Der Aufbau wird in dieser Arbeit
als Art des Modells bezeichnet. Die gemessene abhängige Variable ist die
Laufzeit des Optimierungsvorgangs. Unabhängige Variablen sind Variablen, welche
aktiv verändert werden, während abhängige Variablen gemessen werden
\autocite[vgl.][S.236]{EmpirischeMethoden}. Damit Messergebnisse sinnvoll
vergleichen werden können, dürfen sie sich nur in einem Parameter unterscheiden
\autocite[vgl.][S.236]{EmpirischeMethoden}. Deshalb werden mehrere Messreihen
durchgeführt, wobei innerhalb einer Messreihe der Art konstant ist, die Größe
jedoch variabel ist. Für jede Art wird eine neue Messreihe begonnen.
Störvariablen, also Einflussfaktoren, welche ebenfalls die abhängigen Variablen
beeinflussen, jedoch während der Messung unkontrolliert auftreten, ist \zB die
Prozessorauslastung des Rechners, auch welchem die Messung durchgeführt wird
\autocite[vgl.][S.237]{EmpirischeMethoden}. Ist der Prozessor weniger
ausgelastet, dann ist die gemessene Zeit vermutlich geringer, als wenn der
Prozessor stark ausgelastet ist.

Um den Einfluss der Störvariablen möglichst
gering zu halten, wird jede Messung $n$ mal wiederholt. Aus diesen Messwerten
wird nun ein Konfidenzintervall gebildet, welches mit der Wahrscheinlichkeit
$1 - \alpha$ den tatsächlichen Erwartungswert $\mu$ enthält. Dazu werden die
Messwerte als eine T-verteilte Zufallsvariable $X$ betrachtet, da $n$ aufgrund
der Dauer einer Messung nicht sehr groß gewählt werden
kann. Die Varianz $\sigma^2$ von $X$ ist dabei unbekannt und muss anhand der Stichprobe geschätzt werden,
für diese Schätzung gilt: $\hat{\sigma}^2 = S^2$ \autocite[vgl][S.528]{Statistik}.
Für das ($1-\alpha$)-Konfidenzintervall ergibt sich deshalb nach \autocite[vgl.][S.533]{Statistik}:

\begin{equation*}
    [\bar{X} - t_{n-1,1-\alpha/2}\sqrt{S^2/n}, \bar{X} + t_{n-1,1-\alpha/2}\sqrt{S^2/n}]
\end{equation*}

$\bar{X}$ ist der Mittelwert der Stichprobe: $\bar{x} = \frac{1}{n}
\displaystyle\sum^{n}_{i=1}x_i$ \autocite[vgl.][S.59]{Statistik}.
$S^2$ ist die korrigierte Stichprobenvarianz: $S^2 =
\frac{1}{n-1}\displaystyle\sum^{n}_{i=1}(x_i-\bar{X})^2$ \autocite[vgl.][S.507]{Statistik}.

Für die verschiedenen Arten von Modellen, werden Modelle, von reellen Abfragen
betrachtet, um aus diesen, allgemeine Regeln festzulegen, mit welchen man
Modelle variabler Größe aber derselben Art erzeugen kann. Die Modelle werden
für die Messung künstlich erzeugt, um die unabhängigen Variablen gezielt
verändern zu können. Auf die reellen Abfragen wird dabei zurückgegriffen, um
die Relevanz der Messung, für reelle Szenarien zu gewährleisten.
\autocite[Vgl.][S.500f]{ExperimentalAnalysis}

Diese Messdaten werden genutzt, um festzustellen, wie sich die Laufzeit der
Optimierung für Modelle bestimmter Art bei steigender Größe verhalten. Dabei
ist besonders interessant, ob sich die Laufzeit zur Größe linear verhält,
beziehungsweise ob es stärker oder schwächer ansteigt. Für die Optimierung des
Algorithmus sind nun die Modellarten interessant, bei welchen die Laufzeit
stärker als linear ansteigt, da diese Modellarten ein besonders hohes Potenzial
haben lange Laufzeiten zu verursachen. Um genauer herauszufinden, in welchem
Teil des Optimierungsalgorithmus besonders viel Zeit benötigt wurde, werden
diese Modelle nochmals mithilfe des in \autoref{sec:arten_performance_analyse}
beschriebenen Profilings untersucht. Dazu werden mehrere Modelle dieser Art
optimiert, während der Profiler protokolliert, in welchen Methoden sich wie
lange aufgehalten wurde. Anschließend muss beurteilt werden, ob die Zeit,
welche in dieser Methode benötigt wird, erwartbar ist oder sie geringer sein
sollte. Beziehungsweise, ob es eine Möglichkeit gibt diesen Teil des
Algorithmus zu beschleunigen.

\todo{Gehört nicht in Konzept}

Da sich die Arbeit auf die Optimierungsfunktion der \ac{CE} beschränkt, kann
sich auch bei den Messungen auf diese beschränkt werden.
Um die Leistung einer
bestimmten Funktion zu untersuchen, eignet sich, das in
\autoref{sec:arten_performance_analyse} beschriebenen, Benchmarking.
Somit sind die Messungen präziser auf diese Funktion ausgerichtet und es wird
Aufwand gespart, welcher auftreten würde, wenn man die Untersuchungen mit einer
HANA-Installation durchführen würde. Um mehrere Ergebnisse eines Benchmarks mit verschiedenen Parametern sinnvoll
miteinander vergleichen zu können, dürfen sich die Parameter, der Messungen nur
in einem Wert unterscheiden. \todo{quelle} Bei der Analyse, wie sich
verschiedene Modelle auf die Laufzeit der Optimierung von diesen auswirken,
sind die Größe und der Aufbau des Modells als Parameter denkbar.  Die Größe
eines Modells könnte \zB die Anzahl der Knoten in diesem sein. Diese ist sehr
leicht festzulegen oder zu verändern. Der Aufbau, im folgenden auch Art des
Modells genannt ist etwas komplizierter. In dieser Arbeit wird die Art eines
Modells wie folgt definiert. Zwei Modelle sind von gleicher Art, wenn sie mit
der gleichen Vorgehensweise erzeugt wurden. \autoref{fig:bsp_modell_art} zeigt
verschiedene Modelle. Von diesen könnten \zB \autoref{bsp_modell_art_1} und
\autoref{bsp_modell_art_2} von der gleichen Art sein, da diese erzeugt wurden,
indem ein \foreignlanguage{english}{Aggregation}-Knoten, $n$
\foreignlanguage{english}{Projection}-Knoten und ein
\foreignlanguage{english}{Table}-Knoten hintereinander gehängt werden. Um die
Größe des Modells auch bei anderen Erzeugungsmethoden einfach festlegen zu
können wird die Größe eines Modells abhängig von der Erzeugungsmethode
definiert. Die Größe ist also nicht immer gleich der Anzahl der Knoten in einem
Modell. Bei \autoref{bsp_modell_art_1} und \autoref{bsp_modell_art_2} könnte
die Größe \zB die Anzahl der \foreignlanguage{english}{Projection}-Knoten im
Modell sein. Das Modell wird durch eine Funktion beschrieben, welche für einen
Parameter $n$ ein Modell der Größe $n$ erzeugt. Um beide Parameter zu
untersuchen, wird für beide Parameter eine Menge von Werten festgelegt.
Anschließend wird das kartesische Produkt dieser beiden Mengen gebildet, um
eine Menge von Parameterpaaren zu erhalten. Die Messung wird nun für jedes Paar
dieser Menge ausgeführt. \todo{quelle} Google Benchmarks bieten eine
Funktionalität sie mit mehreren Parametern auszuführen.

Der Benchmark kann also genutzt werden, um zu untersuchen, wie sich die Dauer
der Optimierung von bestimmte Arten von Modellen mit verschiedenen Größen verhält.
Beispielhaft könnte man die Größen $G$ und die Arten $A$  festlegen.

\begin{equation*}
G=\{2;4;8\}
\qquad A=\{j;p\}
\end{equation*}


\begin{equation*}
K = G \times A = \{(2,j);(4,j);(8,j);(2,p);(4,p);(8,p)\}
\end{equation*}

Das kartesische Produkt $K$ ist eine Menge von Tupeln $(g,a)$. Jedes Tupel
spiegelt eine Kombination von Parametern wider, für welche der Benchmark
ausgeführt wird. Für alle $(g,a) \in K$ wird das Modell der Art $a$ und der
Größe $g$ optimiert und die Dauer dieser Optimierung gemessen.

\begin{figure}
    \begin{subfigure}[b]{0.3\textwidth}
        \input{Bilder/tikz/modell_projektionen_1.tex}
        \caption{Beispiel 1}\label{bsp_modell_art_1}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \input{Bilder/tikz/modell_projektionen_2.tex}
        \caption{Beispiel 2}\label{bsp_modell_art_2}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \input{Bilder/tikz/modell_join.tex}
        \caption{Beispiel 3}\label{bsp_modell_art_3}
    \end{subfigure}
    \caption{Beispiel Modelle}\label{fig:bsp_modell_art}
\end{figure}
